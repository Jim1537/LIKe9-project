/*
  LK9analog
    Простая библиотека чтения аналоговых значений с внешних устройств.
    (фоторезисторы, сенсоры серии MQ, простые микрофоны уровня шума и т.п. устройств)

    by Vladimir Gorshunin aka Jim (http://jimblog.me)
    для проекта LIKe9 (http://like9.jimblog.me)

  Особенности:
    - Чтение значений с заданным интервалом (таймер сохраняет интервал даже при переполнении millis())
    - Фильтрация значений / устранение шумов (упрощённый Калман для одномерного случая)
    [спасибо, Alex Gyver: https://github.com/AlexGyver/GyverLibs]

    - Настройка диапазона чтения
    - Настройка параметров фильтрации

    - Получение исходных значений (0-1023)
    - Получение фильтрованных значений с фильтрацией (0-1023)
    - Получение адаптированных фильтрованных значений (0-255)
*/

// Включение библиотеки LK9analog в скетч:
#include "LK9analog.h"

/*
  Определение констант...
    Не обязательно определять те константы, значения которых будут использованы по умолчанию.
    Для примера, все константы определены с их значениями по умолчанию.
*/

#define PHR_PIN A0                // Вход (аналоговый) сигнала на плате

#define PHR_INTERVAL 3000         // Интервал чтения значений (millis: 3000 = раз в 3 сек.)

#define PHR_LIMIT_MIN 0           // Минимальный порог значений (подробнее см. ниже)
#define PHR_LIMIT_MAX 1023        // Максимальный порог значений (подробнее см. ниже)

#define LK9ANLG_FILTER_MSR 50.    // Разброс чтений для фильтра (диапазон шума)
#define LK9ANLG_FILTER_ERR 50.    // Разброс оценки чтений для фильтра (подстраивается сам, но можно задать его явно)
#define LK9ANLG_FILTER_GNE 0.5    // Коэффицент скорости изменения значений для фильтра (0.001-1 подбирается опытным путем, в зависимости от величины интервала чтения значений)

/*
  Объявление класса объекта с передачей ему номера входа сигнала на плате:
      Можно объявить сколько угодно объектов (много разных датчиков и сенсоров).
      Во всяком случае, пока хватает аналоговых входов на плате.
      Каждый из объектов будет иметь свой собственный набор параметров.
      Можно задать им всем разные интервалы чтения, разные параметры фильтрации, разные пороги чтения и т.п.
            
	    LK9analog dev2(PHR2_PIN);
	    LK9analog dev3(PHR3_PIN);
	    LK9analog dev4(PHR4_PIN);
	    LK9analog dev5(PHR5_PIN);
	    и т.д.
*/
LK9analog dev1(PHR_PIN);

void setup() {
  Serial.begin(9600);

  /*
    Если планируется использовать все значения параметров по их умолчанию,
    то тут вообще можно ничего не делать.
    Но, для примера, зададим все параметры вручную...

    Интервал чтения: раз в 3 сек.
  */
  dev1.set(PHR_INTERVAL);

  /*
    По умолчанию, для чтения используется ВЕСЬ возможный диапазон значений от 0 до 1023.

    Однако, в большинстве случаев, сенсор или датчик работают в более ограниченном
    диапазоне (500-800, 400-700 и т.п.)

    Для повышения "разрешения" адаптированных значений, можно задать минимальное и максимальное
    пороговое значение для чтения.

        dev1.set(PHR_LIMIT_MIN, PHR_LIMIT_MAX);

    В этом случае, все значения, которые окажутся ниже заданного минимального порогового значения будут приравнены к нему.
    То же самое и со значениями, которые окажутся выше заданного максимального порогового значения.
  */
  dev1.set(PHR_LIMIT_MIN, PHR_LIMIT_MAX);

  /*
    Все описанные выше параметры можно задать одновременно:

        dev1.set(PHR_INTERVAL, PHR_LIMIT_MIN, PHR_LIMIT_MAX);
  */

}

void loop() {
  /* Для обновления значений используется функция update().
    Не имеет значение, как часто она вызывается. В общем случае - чем чаще, тем лучше.
    Непосредственно чтение значений и сопутствующие этому расчеты будут происходить с интервалом,
    заданным для таймера. Во всех остальных случаях, код "пролетит" дальше без задержек.

    Функция вернет логическое true, если в процессе вызова произошло чтение параметров.

    Если необходимо форсировать встроенный таймер объекта, необходимо вызвать функцию
    обновления, с параметром true:

          dev1.update(true);

    В этом случае, внутренний таймер будет сброшен (и начнет отсчет интервала с начала), чтение
    и сопутствующие расчеты значений произведутся НЕМЕДЛЕННО.


    Обновить чтение параметров по таймеру (если функция вернула true, значит произошло чтение и обработка значений (истек заданный интервал)):
  */
  if (dev1.update()) {
    /*
       Если произошло чтение и обработака значений, то их можно получить в адаптированном отфильтрованном виде (0-255):

           dev1.get();

      "Разрешение" адаптированного значения будет зависить от минимального и максимального порогов чтения

      Считывать значения можно когда угодно и в любом месте кода. Но необходимо помнить, что новые значения
      будут даны только после срабатывания внутреннего таймера. Во всех остальных случаях будет возвращено
      последнее обработанное и сохраненное значение.

    */
    Serial.print("Light level:\t");
    Serial.println(dev1.get());
    
    /*
      Дополнительно, всегда можно запросить "сырые" значения без обработки (0-1023):

           dev1.getRaw();

      Или "сырые" значения с отфильтрованным шумом:

          dev1.getRawFiltered();
    */

  }
}
