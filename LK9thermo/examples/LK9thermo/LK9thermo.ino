/*
  LK9thermo
      by Vladimir Gorshunin aka Jim (http://jimblog.me)
      для проекта LIKe9 (http://like9.jimblog.me)

  Простая библиотека чтения простого терморезистора.

  Особенности:
      - Чтение значений с заданным интервалом (таймер сохраняет интервал даже при переполнении millis())
      - Настройка под любой терморезистор
      - Получение значений в Кельвинах, Цельсиях, Фаренгейтах
*/

/*
  Пример параметров терморезистора, согласно спецификации
  RT0:  10000Ω
        Базовое сопротивление терморезистора

  B:    3977K (±0.75%)
        Beta-коэффициент (B).
        Этот параметр зависит от характеристик материала из которого изготовлен терморезистор.
        Всегда указан в спецификации.

  T0:   25C (±5%)
        В силу того, что базовое сопротивление терморезистора напрямую зависит от его температуры, то
        в спецификации всегда указывается при какой именно температуре терморезистор имеет указанное базовое сопротивление.
        Обычно: 25°C
*/


// Включение библиотеки LK9thermo в скетч:
#include "LK9thermo.h"

/*
  Определение констант...
    Не обязательно определять те константы, значения которых будут использованы по умолчанию.
    Для примера, все константы определены с их значениями по умолчанию.
*/
#define THR_PIN A1          // Вход (аналоговый) сигнала на плате

#define THR_INTERVAL 3000   // Интервал чтения значений (millis: 3000 = раз в 3 сек.)

#define THR_VCC 3.3         // Вольтаж сигнала. Обычно, 3.3 вольта (по умолчанию) или 5 вольт. Зависит от платы контроллера.
#define THR_R 10000         // Сопротивление понижающего резистора (Ω; 10000 = 10KΩ)
#define THR_RT0 10000       // Сопротивление терморезистора (Ω; 10000 = 10KΩ)
#define THR_B 3977          // Beta-коэффициент терморезистора (3977)
#define THR_T0 25           // T0 терморезистора в Кельвинах (25С + 273.15)  

/*
  Объявление класса объекта с передачей ему номера входа сигнала на плате:
      Можно объявить сколько угодно объектов (много разных датчиков).
      Во всяком случае, пока хватает аналоговых входов на плате.
      Каждый из объектов будет иметь свой собственный набор параметров.
      Можно задать им всем разные интервалы чтения, разные параметры и т.п.

        LK9thermo dev2(THR_PIN2);
        LK9thermo dev3(THR_PIN3);
        LK9thermo dev4(THR_PIN4);
        и т.д.

*/
LK9thermo dev1(THR_PIN);

void setup() {
  Serial.begin(9600);

  /*
    Если планируется использовать все значения параметров по их умолчанию,
    то тут вообще можно ничего не делать.
    Но, для примера, зададим все параметры вручную:
  */
  dev1.set(THR_INTERVAL, THR_VCC, THR_R, THR_RT0, THR_B, THR_T0);

  /*
    Можно задать только некоторые параметры.

    Настройка только интервала чтения (millis):
        dev1.set(THR_INTERVAL);

    Настройка интервала чтения и вольтажа сигнала:
        dev1.set(THR_INTERVAL, THR_VCC);

    Настройка интервала чтения, вольтажа сигнала и сопротивления понижающего резистора:
        dev1.set(THR_INTERVAL, THR_VCC, THR_R);
    
  */
}

void loop() {
  /* Для обновления значений используется функция update().
    Не имеет значение, как часто она вызывается. В общем случае - чем чаще, тем лучше.
    Непосредственно чтение значений и сопутствующие этому расчеты будут происходить с интервалом,
    заданным для таймера. Во всех остальных случаях, код "пролетит" дальше без задержек.

    Функция вернет логическое true, если в процессе вызова произошло чтение параметров.

    Если необходимо форсировать встроенный таймер объекта, необходимо вызвать функцию
    обновления, с параметром true:

          dev1.update(true);

    В этом случае, внутренний таймер будет сброшен (и начнет отсчет интервала с начала), чтение
    и сопутствующие расчеты значений произведутся НЕМЕДЛЕННО.


    Обновить чтение параметров по таймеру (если функция вернула true, значит произошло чтение
    и обработка значений (истек заданный интервал)):
  */
  if (dev1.update()) {
    /*
       Если произошло чтение и обработака значений, то их можно получить при помощи функций:

        dev1.getK()
        dev1.getC()
        dev1.getF()
        (Кельвин, Цельсии, Фаренгейты, соответственно)
	
      Считывать значения можно когда угодно и в любом месте кода. Но необходимо помнить, что новые значения
      будут даны только после срабатывания внутреннего таймера. Во всех остальных случаях будет возвращено
      последнее обработанное и сохраненное значение.

    */
    Serial.print("Temperature:\t");
    Serial.print(dev1.getK()); Serial.print("°K; \t");
    Serial.print(dev1.getC()); Serial.print("°C; \t");
    Serial.print(dev1.getF()); Serial.print("°F;");
    Serial.print("\n");
  }
}
